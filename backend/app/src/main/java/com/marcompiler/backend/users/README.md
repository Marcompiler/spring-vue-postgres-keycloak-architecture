# Backend - App - Main - Java - Users

## Description

**Any application requiring authentication therefore needs to manage its users** to some extent.

**Authentication** itself is handled by the **SSO**. However, it can be useful to **store additional information** specific to **our application** for our users. This is where this directory comes into play.

Consequently, we have **three elements** here:

- A class for the **"MyUser" entity**.
- A **controller** to manage these entities.
- A **repository** to retrieve/store/update these entities.

### MyUser.java

The **[MyUser class](./MyUser.java)** represents a **user at the application level**. It stores **application-specific information** such as **a unique ID and a nickname**.

Since users are authenticated via SSO, we need a way to **link the user's identity in the SSO to our application**. We therefore add a **`sub`** field in our class, which represents the unique identifier of the user within the SSO.

**This identifier** can be **retrieved from the [Json Web Token (*JWT*)](https://en.wikipedia.org/wiki/JSON_Web_Token)** provided **during the user's registration** in our application. **This registration happens in the controller**.

### MyUserController.java

The **[MyUserController](./MyUserController.java)** provides several functionalities for the frontend to perform **indirect actions on the users** registered in **our application**.

**To register users**, this must be allowed, which is the role of the **`register` method**. Here is its code:

```java
@PostMapping("/register")
public ResponseEntity<?> register(JwtAuthenticationToken auth, @RequestBody Map<String, String> payload)
{
    try {
        String sub = auth.getToken().getClaimAsString(StandardClaimNames.SUB);
        String surname = payload.get("surname");

        MyUser newUser = new MyUser(sub, surname);

        MyUser result = userRepository.save(newUser);

        return ResponseEntity.ok(result.getId());
    }
    catch(DataIntegrityViolationException ex) {
        // If a user with the same sub/nickname already exists, error due to NOT NULL and UNIQUE constraint
        return ResponseEntity
                .status(HttpStatus.CONFLICT)
                .body("A user with the same sub/username already exists !");
    }
    catch (Exception ex) {
        return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("Error while registering user: " + ex.getMessage());
    }
}
```

This is an endpoint accessible via the "`/register`" path of our API. This method has **two parameters**:

- **`auth`**: This is the JWT which, after the user authenticates with the SSO, registers the user in our database via the [repository](#myuserrepositoryjava).  
- **`payload`**: This is the request body content, which in this case is expected to contain a nickname for the new user.

**From `auth` we retrieve the `sub` and from `payload` we retrieve the nickname**. We then instantiate a new user with this information and attempt to save it using our [repository](#myuserrepositoryjava).

**If** a conflict is detected, for example if the nickname and/or `sub` already exists in the database, it will return an **HTTP response indicating the conflict**, signaling that the user is already registered or that the nickname is already taken.

To handle this, users must first be **saved in the database**, which is the role of the [repository](#myuserrepositoryjava).

### MyUserRepository.java

The **[MyUserRepository](./MyUserRepository.java)** acts as an **interface between our database and the application**, allowing the application to interact with the database. It provides **methods inherited from [`JpaRepository`](https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html)** as well as additional methods, such as finding a user by `sub` or by nickname.

## How to Use

From the frontend or HTTPie, **first make sure you are authenticated with the SSO and have obtained a JWT**.

Then, **call the controller endpoint** to register in the API **using the JWT and a nickname** in the request body. By default, this is:

```sh
http://localhost:8081/api/users/register
```

You will then receive an **HTTP 200 (OK) response with the user ID generated by the API**. You can then retrieve/manipulate the user using the `sub` or the unique database ID.

You can also try to retrieve the new user using one of the `getUserBy[...]` methods.
